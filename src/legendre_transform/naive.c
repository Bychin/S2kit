/**
 * @file naive.c
 * @brief Source code for naive discrete Legendre transform.
 *
 * Source code to synthesize functions using a naive DLT based on recurrence.
 * This algorithm is stable and does not require any precomputed functions, but the slowest one.
 */

#include "s2kit/naive.h"

#include <math.h>
#include <string.h>

/**
 * @brief The naive forward discrete Legendre transform.
 *
 * Computes the discrete Legendre transform of a function via summing naively.
 * I.e. this is the <b>forward discrete Legendre transform</b>.
 * 
 * @note See an example of use in test_DLT_naive.c
 *
 * @param data array of size @c 2*bw containing the sample points
 * @param bw bandwidth
 * @param m order
 * @param weights weights for Legendre transform
 * @param result array of size @c bw-m which will contain the coefficients
 * @param pml_table array of size <tt>2*bw*(bw-m)</tt> which contains the
 * precomputed Pmls
 * @param workspace space for computations of size @c 2*bw
 * 
 * @note @p weights should be generated by GenerateWeightsForDLT().
 * @note @p pml_table should be generated by GeneratePmlTable() and contains Legendres with norm equal to 1.
 */
void DLTNaive(double* data, const int bw, const int m, double* weights, double* result, double* pml_table,
              double* workspace) {
    int size = 2 * bw;

    /*
        Apply quadrature weights.

        We only have to differentiate between even and odd weights when doing something like seminaive,
        something which involves the dct. In this naive case, the parity of the order of the transform
        doesn't matter because we are not dividing by sin(x) when precomputing the Legendres
        (because we are not taking their dct). The plain weights are just fine.
    */
    double* weighted_data = workspace;
    for (int i = 0; i < size; ++i)
        weighted_data[i] = data[i] * weights[i];

    for (int i = 0; i < bw - m; ++i) {
        double sum = 0.;
        for (int j = 0; j < size; ++j)
            sum += weighted_data[j] * pml_table[j];

        result[i] = sum;

        pml_table += size;
    }
}

/**
 * @brief The inverse discrete Legendre transform.
 *
 * Synthesizes a function from a list of coefficients of a Legendre series.
 * I.e. this is the <b>inverse discrete Legendre transform</b>.
 *
 * @note See an example of use in test_DLT_naive.c
 *
 * @param coeffs array of size @c bw-m. The first coefficient is for Pmm
 * @param bw bandwidth
 * @param m order
 * @param result array of size @c 2*bw which will contain the synthesized function
 * @param pml_table array of size <tt>2*bw*(bw-m)</tt> which contains the
 * precomputed Pmls
 *
 * @note @p pml_table should be generated by GeneratePmlTable() and contains Legendres with norm equal to 1.
 */
void InvDLTNaive(double* coeffs, const int bw, const int m, double* result, double* pml_table) {
    int size = 2 * bw;

    memset(result, 0, sizeof(double) * size); // make sure result is zeroed out

    for (int i = 0; i < bw - m; ++i) {
        double coeff = coeffs[i];

        if (coeff == 0.) {
            pml_table += size;
            continue;
        }

        for (int j = 0; j < size; ++j)
            result[j] += coeff * pml_table[j];

        pml_table += size;
    }
}
