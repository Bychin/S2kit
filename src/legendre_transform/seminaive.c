/**
 * @file seminaive.c
 * @brief Source code for seminaive discrete Legendre transform.
 *
 * Source code for computing the Legendre transform where projections are carried out in cosine
 * space, i.e., the seminaive algorithm.
 * For a description, see the related paper or Sean's thesis. // TODO link
 */

#include "s2kit/seminaive.h"

#include <math.h>
#include <stdio.h>
#include <string.h>

#include <fftw3.h>

#include "s2kit/cospml.h"

/**
 * @brief Computes the <b>inverse Legendre transform</b> using the transposed seminaive algorithm.
 *
 * @note See an example of use in test_DLT_semi.c
 *
 * Because the Legendre transform is orthogonal, the inverse can be computed by transposing the
 * matrix formulation of the problem.
 * 
 * (see the description of DLTSemi() for forward Legendre transform)
 *
 * Then to do the inverse:
 * @code f = trans(C) trans(P) l @endcode
 *
 * so we need to transpose the matrix @c P from the forward transform and then do a cosine series
 * evaluation. No quadrature matrix is necessary. If order @p m is odd, then there is also a sin
 * factor that needs to be taken into account.
 *
 * @param coeffs array of length @c bw-m containing associated Legendre series
 * coefficients, assumed that first entry contains the @c P(m,m) coefficient
 * @param bw problem bandwidth
 * @param m order of the associated Legendre functions
 * @param result array of @c 2*bw samples representing the evaluation of the Legendre
 * series at @c 2*bw Chebyshev nodes
 * @param trans_cos_pml_table array of the linearized form of @c trans(P) from the
 * description of this function
 * @param sin_values array is used when @p m is odd in generation of the values in @c trans(P)
 * @param workspace space for computations of size @c 2*bw
 * @param plan pointer to @c fftw_plan with input array being fcos and output being result
 *
 * @note This function was written to be a part of the full spherical harmonic transform, so a lot
 * of precomputation has been assumed.
 * @note @p trans_cos_pml_table should be generated by TransposeCosPmlTable().
 * @warning We use the guru interface to execute inverse DFT so we can apply the same plan to
 * different arrays. Thus, the @p plan should be:\n
 * <tt>fftw_plan_r2r_1d(2*bw, fcos, result, FFTW_REDFT01, FFTW_ESTIMATE)</tt>
 */
void InvDLTSemi(double* coeffs, const int bw, const int m, double* result, double* trans_cos_pml_table,
                double* sin_values, double* workspace, fftw_plan* plan) {
    int size = 2 * bw;

    // for paranoia, zero out arrays
    memset(workspace, 0, sizeof(double) * size);
    memset(result, 0, sizeof(double) * size);

    double* fcos = workspace;
    double* trans_tableptr = trans_cos_pml_table;

    double coeff = 0.5 / sqrt(bw);
    /* 
        main loop - compute each value of fcos

        Note that all zeroes have been stripped out of the
        `trans_cos_pml_table`, so indexing is somewhat complicated.
    */
    for (int i = 0; i < bw; ++i) {
        if (i == (bw - 1) && m % 2) {
            fcos[bw - 1] = 0.0;
            break;
        }

        double* assoc_offset;
        if (i > m)
            assoc_offset = coeffs + (i - m) + (m % 2);
        else
            assoc_offset = coeffs + (i % 2);

        int rowsize = Transpose_RowSize(i, m, bw);

        double value = 0.;
        for (int j = 0; j < rowsize; ++j)
            value += assoc_offset[2 * j] * trans_tableptr[j];

        fcos[i] = value * coeff; // scale coefficients prior to taking inverse DCT

        trans_tableptr += rowsize;
    }

    // special coeff for the first one
    fcos[0] /= (sqrt(size) * coeff);

    /*
        now we have the cosine series for the result,
        so now evaluate the cosine series at `2*bw` Chebyshev nodes
    */

    // take the inverse dct
    // Note that I am using the guru interface
    fftw_execute_r2r(*plan, fcos, result);

    if (!(m % 2))
        return;

    // if m is odd, then need to multiply by sin(x) at Chebyshev nodes
    for (int i = 0; i < size; ++i)
        result[i] *= sin_values[i];
}

/**
 * @brief Computes the <b>Legendre transform</b> of data using the seminaive algorithm.
 *
 * @note See an example of use in test_DLT_semi.c
 *
 * The forward transform looks like:
 * @code l = PCWf @endcode
 * where @c f is the data vector, @c W is a quadrature matrix, @c C is a cosine transform matrix,
 * @c P is a matrix full of coefficients of the cosine series representation of each Pml function
 * <tt>P(m,m) P(m,m+1) ... P(m,bw-1)</tt>, and @c l is the (associated) Legendre series
 * representation of @c f.
 *
 * @param data array of size @c 2*bw containing function to be transformed, assumes sampling at
 * Chebyshev nodes
 * @param bw bandwidth of the problem
 * @param m order of the problem
 * @param result array of length bw for returning computed Legendre coefficients, contains `bw-m`
 * coeffs, with the <tt><f,P(m,m)></tt> coefficient located in <tt>result[0]</tt>
 * @param workspace space for computations of size @c 4*bw
 * @param cos_pml_table array containing the cosine series coefficients of the Pmls (or Gmls) for
 * this problem
 * @param weights array of size @c 4*bw which holds the weights for both even (starting at
 * <tt>weights[0]</tt>) and odd (<tt>weights[2*bw]</tt>) transforms
 * @param plan pointer to @c fftw_plan with input array being weighted_data and output being
 * cos_data
 *
 * @note This function was written to be a part of the full spherical harmonic transform, so a lot
 * of precomputation has been assumed.
 * @note @p cos_pml_table should be generated with GenerateCosPmlTable(). The offset for a
 * particular Pml can be found with TableOffset(), the size of the table - with the TableSize().
 * Since the cosine series are always zero-striped, the zeroes have been removed.
 * @note @p weights should be generated by GenerateWeightsForDLT().
 * @warning We use the guru interface to execute inverse DFT so we can apply the same plan to
 * different arrays. Thus, the @p plan should be:\n
 * <tt>fftw_plan_r2r_1d(2*bw, weighted_data, cos_data, FFTW_REDFT10, FFTW_ESTIMATE)</tt>
 */
void DLTSemi(double* data, const int bw, const int m, double* result, double* workspace, double* cos_pml_table,
             double* weights, fftw_plan* plan) {
    // TODO add check 0 <= `m` < `bw` (and to any other func)
    int size = 2 * bw;

    double* weighted_data = workspace;
    double* cos_data = weighted_data + size;

    // apply quadrature weights to the data and compute the cosine transform
    if (m % 2)
        for (int i = 0; i < size; ++i)
            weighted_data[i] = data[i] * weights[2 * bw + i];
    else
        for (int i = 0; i < size; ++i)
            weighted_data[i] = data[i] * weights[i];

    // smooth the weighted signal
    fftw_execute_r2r(*plan, weighted_data, cos_data);

    // normalize
    cos_data[0] *= M_SQRT1_2;
    double coeff = 1. / sqrt(2. * size);
    for (int i = 0; i < size; ++i)
        cos_data[i] *= coeff;

    /*
        Do the projections.
        Note that the `cos_pml_table` has had all the zeroes
        stripped out so the indexing is complicated somewhat
    */
    int toggle = 0;
    for (int i = m; i < bw; ++i) {
        double* pml_ptr = cos_pml_table + TableOffset(m, i);

        double value = 0.;
        for (int j = 0; j < (i / 2); ++j)
            value += cos_data[(2 * j) + toggle] * pml_ptr[j];

        if (!((i - m) % 2) || !(m % 2))
            value += cos_data[(2 * (i / 2)) + toggle] * pml_ptr[(i / 2)];

        result[i - m] = value;

        toggle = (toggle + 1) % 2;
    }
}
